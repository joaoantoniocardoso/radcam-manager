use std::{fs, path::PathBuf};

use anyhow::Result;
use regex::Regex;
use ts_rs::TS;

use mcm_client::{Camera, Credentials, Stream, mcm_types};
use radcam_commands::{
    Action, CameraControl,
    protocol::display::{
        advanced_display::AdvancedParameterSetting, base_display::BaseParameterSetting,
    },
};

fn main() -> Result<()> {
    if let Err(error) = generate_typescript_bindings_for_mcm_client() {
        println!("Failed generating typecript bindings for MCM: {error:?}");
        return Err(error);
    }

    if let Err(error) = generate_typescript_bindings_for_autopilot() {
        println!("Failed generating typecript bindings for Autopilot: {error:?}");
        return Err(error);
    }

    if let Err(error) = generate_typescript_bindings_for_radcam() {
        println!("Failed generating typecript bindings for RadCam: {error:?}");
        return Err(error);
    }

    println!("Typescript bindings successifully generated!");

    Ok(())
}

fn generate_typescript_bindings_for_mcm_client() -> Result<()> {
    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../../");

    let inputs = vec![root_dir.join("backend/libs/mcm_client")];
    let output = root_dir.join("frontend/src/bindings/mcm_client.d.ts");

    if fs::remove_file(output.clone()).is_err() {
        let output_dir = output.parent().unwrap();
        fs::create_dir_all(output_dir).unwrap();
    }

    let tsync_bindings = {
        tsync::generate_typescript_defs(inputs, output.clone(), false, false);

        fs::read_to_string(&output)?
            .replace("declare ", "export ")
            .replace("type ", "export type ")
            .replace("interface ", "export interface ")
    };

    let ts_rs_bindings = {
        // Generate all typescript bindings and join them into a single String
        let bindings = [
            Camera::export_to_string()?,
            Credentials::export_to_string()?,
            Stream::export_to_string()?,
            mcm_types::VideoEncodeType::export_to_string()?,
            mcm_types::CaptureConfiguration::export_to_string()?,
            mcm_types::VideoSourceType::export_to_string()?,
            mcm_types::VideoSourceOnvifType::export_to_string()?,
            mcm_types::Info::export_to_string()?,
            mcm_types::ApiVideoSource::export_to_string()?,
            mcm_types::Format::export_to_string()?,
            mcm_types::Size::export_to_string()?,
            mcm_types::FrameInterval::export_to_string()?,
            mcm_types::StreamInformation::export_to_string()?,
            mcm_types::ExtendedConfiguration::export_to_string()?,
            mcm_types::VideoCaptureConfiguration::export_to_string()?,
            mcm_types::RedirectCaptureConfiguration::export_to_string()?,
            mcm_types::StreamStatus::export_to_string()?,
            mcm_types::VideoAndStreamInformation::export_to_string()?,
            mcm_types::VideoSourceOnvif::export_to_string()?,
            mcm_types::OnvifDeviceInformation::export_to_string()?,
            mcm_types::PostStream::export_to_string()?,
            mcm_types::RemoveStream::export_to_string()?,
            mcm_types::OnvifDevice::export_to_string()?,
            mcm_types::AuthenticateOnvifDeviceRequest::export_to_string()?,
            mcm_types::UnauthenticateOnvifDeviceRequest::export_to_string()?,
        ]
        .join("\n\n");

        // // Remove all typescript "import type" because all types are going to live in the same typescritp file
        let re = Regex::new(r"(?m)^import type .*\n")?;
        re.replace_all(bindings.as_str(), "").to_string()
    };

    let bindings = ts_rs_bindings + &tsync_bindings;

    // Replace all notices by a custom one
    let bindings = {
        let re = Regex::new(r".*This file.*")?;
        let mut bindings = re.replace_all(bindings.as_str(), "\n").to_string();

        let custom_notice_str = "/* This file was generated using `cargo run --bin=bindings`. Do not edit this file manually. */\n";
        bindings.insert_str(0, custom_notice_str);
        bindings.as_str().replace("\n\n\n", "\n")
    };

    fs::write(output, bindings)?;

    Ok(())
}

fn generate_typescript_bindings_for_autopilot() -> Result<()> {
    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../../");

    let inputs = vec![root_dir.join("backend/libs/autopilot")];
    let output = root_dir.join("frontend/src/bindings/autopilot.d.ts");

    if fs::remove_file(output.clone()).is_err() {
        let output_dir = output.parent().unwrap();
        fs::create_dir_all(output_dir).unwrap();
    }

    let tsync_bindings = {
        tsync::generate_typescript_defs(inputs, output.clone(), false, false);

        fs::read_to_string(&output)?
            .replace("declare ", "export ")
            .replace("type ", "export type ")
            .replace("interface ", "export interface ")
    };

    let ts_rs_bindings = {
        // Generate all typescript bindings and join them into a single String
        let bindings = [
            autopilot::ActuatorsControl::export_to_string()?,
            autopilot::Action::export_to_string()?,
            autopilot::ActuatorsState::export_to_string()?,
            autopilot::ActuatorsConfig::export_to_string()?,
            autopilot::parameters::ActuatorsParametersConfig::export_to_string()?,
            autopilot::parameters::ServoChannel::export_to_string()?,
            autopilot::parameters::ScriptFunction::export_to_string()?,
            autopilot::FocusZoomPoints::export_to_string()?,
            autopilot::FocusZoomPoint::export_to_string()?,
        ]
        .join("\n\n");

        // // Remove all typescript "import type" because all types are going to live in the same typescritp file
        let re = Regex::new(r"(?m)^import type .*\n")?;
        re.replace_all(bindings.as_str(), "").to_string()
    };

    let bindings = ts_rs_bindings + &tsync_bindings;

    // Replace all notices by a custom one
    let bindings = {
        let re = Regex::new(r".*This file.*")?;
        let mut bindings = re.replace_all(bindings.as_str(), "\n").to_string();

        let custom_notice_str = "/* This file was generated using `cargo run --bin=bindings`. Do not edit this file manually. */\n";
        bindings.insert_str(0, custom_notice_str);
        bindings.as_str().replace("\n\n\n", "\n")
    };

    fs::write(output, bindings)?;

    Ok(())
}

fn generate_typescript_bindings_for_radcam() -> Result<()> {
    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../../");

    let inputs = vec![root_dir.join("backend/libs/radcam_commands")];
    let output = root_dir.join("frontend/src/bindings/radcam.ts");

    let _ = fs::remove_file(output.clone());

    let tsync_bindings = {
        tsync::generate_typescript_defs(inputs, output.clone(), false, false);

        fs::read_to_string(&output)?
            .replace("declare ", "export ")
            .replace("type ", "export type ")
    };

    let ts_rs_bindings = {
        // Generate all typescript bindings and join them into a single String
        let bindings = [
            CameraControl::export_to_string()?,
            Action::export_to_string()?,
            BaseParameterSetting::export_to_string()?,
            AdvancedParameterSetting::export_to_string()?,
        ]
        .join("\n\n");

        // Remove all typescript "import type" because all types are going to live in the same typescritp file
        let re = Regex::new(r"(?m)^import type .*\n")?;
        re.replace_all(bindings.as_str(), "").to_string()
    };

    let bindings = ts_rs_bindings + &tsync_bindings;

    // Replace all notices by a custom one
    let bindings = {
        let re = Regex::new(r".*This file.*")?;
        let mut bindings = re.replace_all(bindings.as_str(), "\n").to_string();

        let custom_notice_str = "/* This file was generated using `cargo run --bin=bindings`. Do not edit this file manually. */\n";
        bindings.insert_str(0, custom_notice_str);
        bindings.as_str().replace("\n\n\n", "\n")
    };

    fs::write(output, bindings)?;

    Ok(())
}
